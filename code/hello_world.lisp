(defun hello-world ()
  (format t "hello , world"))

( * 2 2)

(defun square (x)
  (* x x))


 (defun triple (x)
	  (* x x x))
(list :a 1 :b 2 :c 3)
(getf (list :a 1 :b 2 :c 3) :a)
(getf (list :a 1 :b 2 :c 3) :b)
(defun make-cd (title artist rating ripped)
	   (list :title title :artist artist :rating rating :ripped ripped))
(make-cd "culture" "migos" 10 t)
(defvar *db* nil)
(defun add-record (cd) (push cd *db*))
(add-record (make-cd "culture" "migos" 10 t))
(add-record (make-cd "dank" "meh" 12 t))
(add-record (make-cd "hello" "world" 9 t))
(defun dumb-db ()
	   (dolist (cd *db*)
	     (format t "~{~a:~10t~a~%~}~%" cd)))
(atom *db*)
(symbolp *db*)
(atom 'a)
(atom 'b)
(atom 'c)
(atom 'zuriel)
(atom '(zuriel))
(atom '(zuriel victory laptop chair))
(consp '(zuriel victory laptop chair))
(consp *db*)
(defvar x 2)
(defvar x 3)
(defparameter x 2)
(defparameter x 3)
(consp x)
(defparameter objects-around-me '(phone mirror mattress pen))
(atom objects-around-me)
(defvar objects-around-me '(phone mirror mattress pen))
(consp objects-around-me)
*db*
(atom x)
'(+ 1 2)
(defparameter x (+ 3 5))
(defun dumb-db ()
  (format t "~{~{~a:10t~%~}~%~}" *db*))
(defun prompt-read (prompt)
	   (format *query-io* "~a: " prompt)
	   (force-output *query-io*)
	   (read-line *query-io*))
(defun prompt-for-cd ()
	   (make-cd
	    (prompt-read "Title")
	    (prompt-read "Artist")
	    (prompt-read "Rating")
	    (prompt-read "Ripped [y/n]")))
;(parse-integer (prompt-read "Rating") :junk-allowed t)
;(or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)
(defun prompt-for-cd ()
	   (make-cd
	    (prompt-read "Title")
	    (prompt-read "Artist")
	    (or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)
	    (y-or-n-p "Ripped [y/n]")))
(defun add-cds ()
	   (loop (add-record (prompt-for-cd))
	      (if (not (y-or-n-p "Another? [y/n]: ")) (return))))
(defun save-db (filename)
	   (with-open-file (out filename
				:direction :output
				:if-exists :supersede)
	     (with-standard-io-syntax
	       (print *db* out))))
(save-db "~/LearningEthereum/code/my-cds.db")
(defun load-db (filename)
	   (with-open-file (in filename)
	     (with-standard-io-syntax
	       (setf *db* (read in)))))
(remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9 10))
(mapcar #'square '(1 2 3 4 5 6))
(remove-if-not #'(lambda (x) (= 0 (mod x 2))) '(1 2 3 4 5 6 7 8 9 10))
(defun our-evenp (x)
  (= 0 (mod x 2)))
(remove-if-not
 #'(lambda (cd) (equal (getf cd :artist)  "migos")) *db*)
(defun select-by-artist (artist)
	   (remove-if-not
	    #'(lambda (cd) (equal (getf cd :arist) artist))
	    *db*))
(defun select (selector-fn)
  (remove-if-not selector-fn *db*))
;(select #'(lambda (cd) (equal (getf cd :artist) "migos")))
(defun artist-selector (artist)
  #'(lambda (cd) (equal (getf cd :artist) artist)))
(defun foo (a b c) (list a b c))
(defun foo (&key a b c) (list a b c))
(defun foo (&key a (b 20) (c 30 c-p)) (list a b c c-p))
(defun update (selector-fn &key title artist rating (ripped nil ripped-p))
	   (setf *db*
		 (mapcar
		  #'(lambda (row)
		      (when (funcall selector-fn row)
			(if title (setf (getf row :title) title))
			(if artist (setf (getf row :artist) artist))
			    (if rating (setf (getf row :rating) rating))
			    (if ripped-p (setf (getf row :ripped) ripped)))row) *db*)))
(defun where (&key title artist rating (ripped nil ripped-p))#'(lambda (cd)
									  (and 
									   (if title (equal (getf cd :title) title) t)
									   (if artist (equal (getf cd :artist) artist) t)
									   (if rating (equal (getf cd :rating) rating) t)
									   (if ripped-p (equal (getf  cd :ripped) ripped) t))))
(defun where (&key title artist rating (ripped nil ripped-p))#'(lambda (cd)
									  (and 
									   (if title (equal (getf cd :title) title) t)
									   (if artist (equal (getf cd :artist) artist) t)
									   (if rating (equal (getf cd :rating) rating) t)
									   (if ripped-p (equal (getf  cd :ripped) ripped) t))))(defun where (&key title artist rating (ripped nil ripped-p))#'(lambda (cd)
									  (and 
									   (if title (equal (getf cd :title) title) t)
									   (if artist (equal (getf cd :artist) artist) t)
									   (if rating (equal (getf cd :rating) rating) t)
									   (if ripped-p (equal (getf  cd :ripped) ripped) t))))
(defun where (&key title artist rating (ripped nil ripped-p))#'(lambda (cd)
									  (and 
									   (if title (equal (getf cd :title) title) t)
									   (if artist (equal (getf cd :artist) artist) t)
									   (if rating (equal (getf cd :rating) rating) t)
									   (if ripped-p (equal (getf  cd :ripped) ripped) t))))
(defun delete-rows (selector-fn)
	   (setf *db* (remove-if selector-fn *db*)))
(reverse '(1 2 3))
(defmacro backwards (expr) (reverse expr))
(defmacro backwards (expr) (reverse expr))(backwards ("hello, world" t format))
(defun make-comparison-expr (field value)
  (list 'equal (list 'getf 'cd field) value))
;(make-comparison-expr :rating 10)
'(1 2 (+ 1 2))
(defun make-comparisons-list (fields)
	   (loop while fields
		collecting (make-comparison-expr (pop fields) (pop fields))))
(defmacro where (&rest clauses)
  ` #'(lambda (cd) (and ,@(make-comparisons-list clauses))))

`(and ,(list 1 2 3))
(symbolp #'square)
(where :title "migos" :ripped t)
(macroexpand-1 '(where :title "culture" :title t))
;(select (where :title "culture" :ripped t))

;;REPL: Read Evaluate Print Loop

(defun zuriels-programming-language ()
  (format t "~&zuriels-repl> ")
  (print (eval (read)))
  (zuriels-programming-language))
(defun name (parameter*)
	   "Optional documentation string."
	   body-form*)
(defun verbose-sum (x y)
	   "sum any two numbers after printing a message."
	   (format t "summing `d and `d. `%" x y)
	   (+ x y))
(defun foo (a b &optional c d) (list a b c d))
(defun foo (a &optional (b 10)) (list a b))
(defun make-rectangle  (width &optional (height width)))
(defun foo (a b &optional (c 3 c-supplied-p))
  (list a b c c-supplied-p))
(defun foo (&key a b c) (list a b c))
(defun foo (&key (a 0) (b 0 b-supplied-p) (c (+ a b)))
	   (list a b c b-supplied-p))
(defun foo (&key ((:apple a)) ((:box b) 0) ((:charlie c) 0 c-supplied-p))
  (list a b c c-supplied-p))
(defun foo (x &optional y &key z) (list x y z))
(defun foo (&rest rest &key a b c) (list rest a b c))
(defun  foo (n)
	   (dotimes (i 10)
	     (when (> (* i  j) n)
	       (return-from foo (list i j)))))
(defun foo (x) (* 2 x))
(function foo)
#'foo
(defun plot (fn min  max step)
	   (loop for i from min to max by step do
		(loop repeat (funcall fn i) do (format t "*"))
		(format  t "~%")))
(plot #'exp 0 4 1/2)
(defun f (x y)
  (+ (square x) (square y)))
(f 2 3)
((lambda (x y) (+ x y)) 2 3)
(plot #'double1 0 10 1)
